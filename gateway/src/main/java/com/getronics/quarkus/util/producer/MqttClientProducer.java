package com.getronics.quarkus.util.producer;

import java.security.KeyStore;

import javax.annotation.PostConstruct;
import javax.annotation.PreDestroy;
import javax.enterprise.context.ApplicationScoped;
import javax.enterprise.inject.Produces;
import javax.inject.Inject;
import javax.net.ssl.SSLContext;
import javax.net.ssl.TrustManagerFactory;

import org.eclipse.microprofile.config.inject.ConfigProperty;
import org.slf4j.Logger;

import io.vertx.core.net.JksOptions;
import io.vertx.mqtt.MqttClientOptions;
import io.vertx.mutiny.core.Vertx;
import io.vertx.mutiny.mqtt.MqttClient;

/**
 * The Class MqttConnectionProducer.
 *
 * @author andreabattaglia
 */
@ApplicationScoped
public class MqttClientProducer {

    /** The logger. */
    @Inject
    Logger LOGGER;

    /** The host. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.host")
    String host;

    /** The port. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.port")
    short port;

    /** The enable ssl. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.ssl")
    boolean enableSsl;

    /** The keystore location. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.ssl.keystore.location")
    String keystoreLocation;

    /** The keystore password. */
    @ConfigProperty(name = "qiot.mqtt.client.connection.ssl.keystore.password")
    String keystorePassword;

    /** The truststore location. */
    @ConfigProperty(
            name = "qiot.mqtt.client.connection.ssl.truststore.location")
    String truststoreLocation;

    /** The truststore password. */
    @ConfigProperty(
            name = "qiot.mqtt.client.connection.ssl.truststore.password")
    String truststorePassword;

    /** The options. */
    MqttClientOptions options;

    /** The ssl context. */
    SSLContext sslContext;

    /** The trust manager factory. */
    TrustManagerFactory trustManagerFactory;

    /** The key store. */
    KeyStore keyStore;

    @Inject
    Vertx vertx;

    private MqttClient client;


    /**
     * Inits the.
     *
     * @throws Exception
     *             the exception
     */
    @PostConstruct
    void init() throws Exception {

        options = new MqttClientOptions();
        options.setReconnectAttempts(-1);
        options.setCleanSession(true);
        options.setAutoKeepAlive(true);
        options.setAutoGeneratedClientId(true);
        options.setSsl(enableSsl);
        options.setKeyCertOptions(getKeyCertOptions());
        options.setTrustOptions(getTrustOptions());
        options.setMaxInflightQueue(65535);
        
        LOGGER.debug("Vert.x Mqtt client options: {}", options);
        
        client = MqttClient.create(vertx, options);
    }

    private JksOptions getKeyCertOptions() {
        LOGGER.debug("getKeyCertOptions() - start");

        JksOptions returnJksOptions = new JksOptions().setPath(keystoreLocation).setPassword(keystorePassword);
        LOGGER.debug("getKeyCertOptions() - end - return value={}", returnJksOptions);
        return returnJksOptions;
    }

    private JksOptions getTrustOptions() {
        LOGGER.debug("getTrustOptions() - start");

        JksOptions returnJksOptions = new JksOptions().setPath(truststoreLocation).setPassword(truststorePassword);
        LOGGER.debug("getTrustOptions() - end - return value={}", returnJksOptions);
        return returnJksOptions;
    }

    /**
     * Produce mqtt connection.
     *
     * @return the mqtt client
     */
    @Produces
    public MqttClient produceMqttClient() {
        if (!client.isConnected()) {
            connectClient();

        }
        return client;
    }

    private void connectClient() {
        client.connectAndAwait(port, host, null);
        LOGGER.info("Client connected: {}", client.isConnected());
        // client.ping();
    }

    /**
     * Destroy.
     */
    @PreDestroy
    void destroy() {
        if (client != null && client.isConnected())
            client.disconnectAndForget();
    }
  

}
